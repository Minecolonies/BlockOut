plugins {
    id "com.matthewprenger.cursegradle" version "1.1.0"
}

apply plugin: 'net.minecraftforge.gradle.forge'
apply plugin: 'maven'

archivesBaseName = "BlockOut"

sourceCompatibility = targetCompatibility = '1.8' // Need this here so eclipse task generates correctly.
compileJava {
    sourceCompatibility = targetCompatibility = '1.8'
}

minecraft {
    version = minecraft_version + "-" + forge_version
    runDir = "run"

    mappings = "${blockout_mappings}"

    replace "@VERSION@", project.version
    replace "@MCVERSION@", minecraft_version
    replace "@FORGEVERSION@", forge_version

    // Set the jar signature in code prior to compilation, if it exists as a build property
    if (project.hasProperty("signature")) {
        replace "@FINGERPRINT@", project.signature
    }
}

processResources {
    // this will ensure that this task is redone when the versions change.
    inputs.property "version", project.version
    inputs.property "mcversion", project.minecraft.version

    // replace stuff in mcmod.info, nothing else
    from(sourceSets.main.resources.srcDirs) {
        include 'mcmod.info'

        // replace version and mcversion
        expand 'version':project.version, 'mcversion':project.minecraft.version
    }

    // copy everything else except the mcmod.info
    from(sourceSets.main.resources.srcDirs) {
        exclude 'mcmod.info'
    }
}

task signJar(type: SignJar, dependsOn: reobfJar) {
    onlyIf { // Skip the task if our secret data isn't available
        project.hasProperty('keyStore')
    }

    if (project.hasProperty('keyStore')) {
        keyStore = project.keyStore // This needs to be a path to the keystore file
        alias = project.keyStoreAlias
        storePass = project.keyStorePass
        keyPass = project.keyStoreKeyPass
        inputFile = jar.archivePath
        outputFile = jar.archivePath
    }
}

idea {
    module {
        inheritOutputDirs = false
        outputDir = file('out')
        testOutputDir = file('out_test')
    }
}

build.dependsOn signJar

configurations {
    shade {
        transitive = false
    }
    shadeTransitive{}
    shade.extendsFrom shadeTransitive
}

dependencies {
    shadeTransitive project(':api')
    shade project(':main')
    shade project(':lang:json')
    shade (group: 'com.ldtteam', name: 'JVoxelizer', version: jvoxelizer_version, classifier: 'forge-1.12')

    compile project(':api')
    compile project(':main')
    compile project(':lang:json')
    deobfCompile (group: 'com.ldtteam', name: 'JVoxelizer', version: jvoxelizer_version, classifier: 'forge-1.12')
}

jar {
    from (configurations.shade.files){
        include '*'
        into 'META-INF/libraries'
    }

    manifest {
        attributes([
                'ContainedDeps': configurations.shade.files.collect { it.name }.join(' '),
                'Maven-Artifact': "${project.group}:${project.archivesBaseName}:${project.version}:api",
                'Timestamp': System.currentTimeMillis(),
                'FMLAT': "blockout_at.cfg"
        ])
    }

    classifier 'universal-forge-1.12'
}

artifacts {
    archives sourceJar
}

curseforge {
    if (System.getenv().CURSEAPIKEY != null && System.getenv().CURSERELEASETYPE != null)
    {
        apiKey = System.getenv().CURSEAPIKEY

        project {
            id = '275314'

            changelog = file('build/changelog.md')
            changelogType = 'markdown'
            releaseType = System.getenv().CURSERELEASETYPE

            mainArtifact(jar) {
                displayName = "BlockOut: $project.version"
            }

            addArtifact jar
            addArtifact javadocJar
            addArtifact sourceJar
        }
    }
    else
    {
        logger.lifecycle("Cannot run the CurseUpload sequence. No API-Key or release type has been provided.")
    }
}

task("createChangelog") {
    group = 'upload'

    doLast {
        def teamCityURL = "https://teamcity.minecolonies.com/"
        def file = new FileOutputStream("build/changelog.md")
        def out = new BufferedOutputStream(file)
        def changesXML = new XmlSlurper().parse(teamCityURL + "guestAuth/app/rest/changes?locator=build:(id:" + teamcity["teamcity.build.id"] + ")")

        def changes = changesXML.change
        project.logger.lifecycle("createChangelog: Identified " + changes.size() + " changes to be written into the changelog.")

        out << "# Blockout Changelog \n"
        out << "## Version: _" + version + "_ \n"

        if (changes.size() > 0) {
            for (int i = 0; i < changes.size(); i++) {
                def changeDetailsURL = teamCityURL + "guestAuth/app/rest/changes/id:" + changes[i].@id.text()
                def changeDetailsXml = new XmlSlurper().parse(changeDetailsURL)
                def changeComment = changeDetailsXml.comment.text().trim()

                out << "* " + changeComment + "\n"
            }
        } else {
            out << "No Changes detected!"
        }

        out.close()
    }
}

